<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>The maximum subarray problem | Weslley’s blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="The maximum subarray problem" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The maximum subarray problem is a classic problem in computer science and can be solved using a variety of algorithmic techniques. Among these techniques are brute force, divide and conquer, dynamic programming, and others. The goal is to find a contiguous subarray with the largest sum within a given one-dimensional array $[a_1, a_2,…, a_n]$ of numbers." />
<meta property="og:description" content="The maximum subarray problem is a classic problem in computer science and can be solved using a variety of algorithmic techniques. Among these techniques are brute force, divide and conquer, dynamic programming, and others. The goal is to find a contiguous subarray with the largest sum within a given one-dimensional array $[a_1, a_2,…, a_n]$ of numbers." />
<link rel="canonical" href="http://localhost:4000/blog/the-maximum-subarray-problem" />
<meta property="og:url" content="http://localhost:4000/blog/the-maximum-subarray-problem" />
<meta property="og:site_name" content="Weslley’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-03-21T00:00:00+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/blog/the-maximum-subarray-problem","headline":"The maximum subarray problem","dateModified":"2021-03-21T00:00:00+00:00","datePublished":"2021-03-21T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/the-maximum-subarray-problem"},"description":"The maximum subarray problem is a classic problem in computer science and can be solved using a variety of algorithmic techniques. Among these techniques are brute force, divide and conquer, dynamic programming, and others. The goal is to find a contiguous subarray with the largest sum within a given one-dimensional array $[a_1, a_2,…, a_n]$ of numbers.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Weslley's blog" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-E622TLYTKG', 'auto');
  ga('send', 'pageview');
}
</script>
  
</head>
<link rel="shortcut icon" type="image/svg" href="/assets/images/logo.svg">
  <body><header class="site-header" role="banner">
  <!--Hard coded desired navbar-->  
  <div class="wrapper">
    <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path         d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/projects/">Projects</a>
            <a class="page-link" href="/physics/">Physics</a>
            <a class="page-link" href="/writing/">Writing</a>
        </div>
      </nav>
    <a class="site-title" rel="author" href="/blog">Weslley&#39;s blog</a></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The maximum subarray problem</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-03-21T00:00:00+00:00" itemprop="datePublished">Mar 21, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">maximum subarray problem</a> is a classic problem in computer science and can be solved using a variety of algorithmic techniques. Among these techniques are <em>brute force</em>, <em>divide and conquer</em>, <em>dynamic programming</em>, and others. The goal is to find a contiguous subarray with the largest sum within a given one-dimensional array $[a_1, a_2,…, a_n]$ of numbers.</p>

<p>The main objective of this article is to present diferent algorithms with diferent time complexities which constitute a solution for this problem.</p>

<h3 id="an-initial-brute-force-solution-with-theta-n3">An initial brute force solution with $\Theta (n^3)$</h3>

<p>What are all the possible contiguous sequences? Let $v$ be an array containing a sequence of integers. Then, the possible sequences are all the subarrays $v[i:j]$ such that $0 \leq i \leq j &lt; n$.</p>

<p>A brute force algorithm would be to go over all the possible subsequences and for each one calculate their sum, returning the greatest sum possible in the end. Let’s suppose we have the array $v$. Then one way to implement this would be:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">maximumSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">v</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">j</span><span class="o">;</span><span class="n">k</span><span class="o">++)</span>
                <span class="n">sum</span><span class="o">+=</span><span class="n">v</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">&gt;</span><span class="n">maxSum</span><span class="o">)</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span>  
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="improving-the-solution-to-theta-n2">Improving the solution to $\Theta (n^2)$</h3>

<p>Intuitively, looking at the previous code you can see that in each sum we are repeating a lot of calculations. When we go from calculating $sum(v[i:j])$ to $sum(v[i:j+1])$ we don’t need to recalculate everything again. In other words, $sum(v[i:j+1]) = sum(v[i:j]) + v[j+1])$. With that we can remove the third loop we had before:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">maximumSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">v</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">!=</span><span class="n">i</span><span class="o">)</span> <span class="n">sum</span><span class="o">+=</span><span class="n">v</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">&gt;</span><span class="n">maxSum</span><span class="o">)</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span>  
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="improving-even-more-to-theta-n">Improving even more to $\Theta (n)$</h3>

<p>A quadratic solution is still not enough for us :). To get to the linear solution, we need to use <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm"><em>Kadane’s algorithm</em></a>. Let’s consider an array $best$ with the same length as $v$. Then, $best[i]$ represents the subarray with maximum sum which ends at position $i$. It’s easy to see that $best[0] = v[0]$. If we know $best[i]$, how can we calculate $best[i+1]$?</p>

<p>Let’s go over an example. Imagine our array $v$ is $v = [4, -2, 1, 5]$. Then,</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>4</td>
      <td>-2</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Now, we know that the best sum up until position $0$ of $v$ is of course $v[0] = 4$. So we have</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>4</td>
      <td>-2</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>4</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Now want to calculate $best[1]$. What we are trying to find is the greatest sum of contiguous elements in $v$ up until position 1. But this value is the current value of $v$ plus the greatest sum up until the previous position. In other words, $best[1] = best[0] + v[1] = 4 + (-2) = 2$. This means 2 is the greatest sum of contiguous elements up until position 1 on array $v$. Then,</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>4</td>
      <td>-2</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>4</td>
      <td>2</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>For $best[2]$ we do the same thing: the maximum sum up until $i = 2$ on array $v$ is simply $best[1] + v[2]$. In this case, $best[2] = best[1] + v[2] = 2 + 1 = 3$.</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>4</td>
      <td>-2</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>4</td>
      <td>2</td>
      <td>3</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>And at last, $best[3] = best[2] + v[3] = 3 + 5 = 8$.</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>4</td>
      <td>-2</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>4</td>
      <td>2</td>
      <td>3</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<p>By now you probably noticed the pattern. To fill out the $best$ array, we say that $best[0] = v[0]$ and that $best[i] = best[i-1] + v[i]$. Then, the maximum subarray sum of contiguous elements is found by obtaining the greatest element of the array $best$. In our case, this value is 8.</p>

<p>But there is a catch. What if $best[i-1]$ is a negative number? Let’s use another example with $v = [-5, 2, -3, 4]$. As usual, $best[0] = v[0] = -5$.</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td>-3</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>-5</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Now, what is the greatest sum of contiguous elements of $v$ up position 1? If we try to do the samething as before by summing $best[0] + v[1]$, we get $best[1] = -3$. But that’s wrong, since $v[1]$ alone is greater than -3. So in this case, $best[1] = 2$. That means that if $best[i-1] &lt; 0$, we don’t sum it with $v[i]$ but leave it as it is. Continuing with our example,</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td>-3</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Now, the best sum up to position $2$ is $best[1] + v[2] = 2 + (-3) = -1$.</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td>-3</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td>-1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Again, $best[2]$ is also negative. Therefore, the greatest sum on $v$ up until position $3$ is $v[3] = 4$.</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$v[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td>-3</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$best[i]$</td>
      <td>-5</td>
      <td>2</td>
      <td>-1</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<p>And the maximum sum of contiguous elements in v is $max(best) = 4$.</p>

<p>And this is Kadane’s algorithm:</p>

\[best[0] = v[0]\]

\[best[i] = 
    \begin{cases}
        best[i-1] + v[i],  &amp; \text{if } best[i-1] &gt; 0\\
        v[i],              &amp; \text{if } best[i-1] &lt; 0
    \end{cases}\]

<p>Let’s implement this idea in Java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">maximumSubarray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">v</span><span class="o">){</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">best</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="n">best</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">best</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]&gt;</span><span class="mi">0</span><span class="o">)</span>
            <span class="n">best</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">best</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">else</span>
            <span class="n">best</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">best</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">best</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">best</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;</span><span class="n">maxSum</span><span class="o">)</span> <span class="n">maxSum</span><span class="o">=</span><span class="n">best</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    
    <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Since we only traverse the array $v$ once to fill in the $best$ array and then loop through it to find its greatest element, we end up with a linear complexity $O(n + n) = O(2n) = O(n)$, where $n$ is the length of the array $v$.</p>

<p>Hopefully after these examples you gained a more detail perception on the maximum subarray problem as well as with using different ideas to decrease the time complexities of algorithms.</p>


  </div><a class="u-url" href="/blog/the-maximum-subarray-problem" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

   

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Weslley&#39;s blog</li><li><a class="u-email" href="mailto:w3slley.victor@gmail.com">w3slley.victor@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w3slley"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w3slley</span></a></li><li><a href="https://www.twitter.com/_w3slley"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_w3slley</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is a place where I share thoughts and ideas about software development, physics and science in general (among other things =D)!</p>
      </div>
    </div>

  </div>

</footer>
<!--MathJax script -->
    <script>
    //script that renders inline latex commands using MathJax
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
  </body>

</html>
